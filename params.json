{
  "name": "Jsonapi-resources",
  "tagline": "A resource-focused Rails library for developing JSON API compliant servers.",
  "body": "# JSONAPI::Resources\r\n\r\n`JSONAPI::Resources`, or \"JR\", provides a framework for developing a server that complies with the\r\n[JSON API](http://jsonapi.org/) specification.\r\n\r\nLike JSON API itself, JR's design is focused on the resources served by an API. JR needs little more than a definition\r\nof your resources, including their attributes and relationships, to make your server compliant with JSON API.\r\n\r\nJR is designed to work with Rails 4.0+, and provides custom routes, controllers, and serializers. JR's resources may be\r\nbacked by ActiveRecord models or by custom objects.\r\n\r\n## Table of Contents\r\n\r\n* [Demo App] (#demo-app)\r\n* [Client Libraries] (#client-libraries)\r\n* [Installation] (#installation)\r\n* [Usage] (#usage)\r\n  * [Resources] (#resources)\r\n    * [JSONAPI::Resource] (#jsonapiresource)\r\n    * [Context] (#context)\r\n    * [Attributes] (#attributes)\r\n    * [Primary Key] (#primary-key)\r\n    * [Model Name] (#model-name)\r\n    * [Model Hints] (#model-hints)\r\n    * [Relationships] (#relationships)\r\n    * [Filters] (#filters)\r\n    * [Pagination] (#pagination)\r\n    * [Included relationships (side-loading resources)] (#included-relationships-side-loading-resources)\r\n    * [Resource meta] (#resource-meta)\r\n    * [Custom Links] (#custom-links)\r\n    * [Callbacks] (#callbacks)\r\n  * [Controllers] (#controllers)\r\n    * [Namespaces] (#namespaces)\r\n    * [Error Codes] (#error-codes)\r\n    * [Handling Exceptions] (#handling-exceptions)\r\n    * [Action Callbacks] (#action-callbacks)\r\n  * [Operation Processors] (#operation-processors)\r\n  * [Serializer] (#serializer)\r\n    * [Serializer options] (#serializer-options)\r\n    * [Formatting] (#formatting)\r\n    * [Key Format] (#key-format)\r\n  * [Routing] (#routing)\r\n    * [Nested Routes] (#nested-routes)\r\n  * [Authorization](#authorization)\r\n  * [Resource Caching] (#resource-caching)\r\n    * [Caching Caveats] (#caching-caveats)\r\n* [Configuration] (#configuration)\r\n* [Contributing] (#contributing)\r\n* [License] (#license)\r\n\r\n## Demo App\r\n\r\nWe have a simple demo app, called [Peeps](https://github.com/cerebris/peeps), available to show how JR is used.\r\n\r\n## Client Libraries\r\n\r\nJSON API maintains a (non-verified) listing of [client libraries](http://jsonapi.org/implementations/#client-libraries)\r\nwhich *should* be compatible with JSON API compliant server implementations such as JR.\r\n\r\n## Installation\r\n\r\nAdd JR to your application's `Gemfile`:\r\n\r\n    gem 'jsonapi-resources'\r\n\r\nAnd then execute:\r\n\r\n    $ bundle\r\n\r\nOr install it yourself as:\r\n\r\n    $ gem install jsonapi-resources\r\n\r\n## Usage\r\n\r\n### Resources\r\n\r\nResources define the public interface to your API. A resource defines which attributes are exposed, as well as\r\nrelationships to other resources.\r\n\r\nResource definitions should by convention be placed in a directory under app named resources, `app/resources`. The file name should be the single underscored name of the model that backs the resource with `_resource.rb` appended. For example,\r\na `Contact` model's resource should have a class named `ContactResource` defined in a file named `contact_resource.rb`.\r\n\r\n#### JSONAPI::Resource\r\n\r\nResources must be derived from `JSONAPI::Resource`, or a class that is itself derived from `JSONAPI::Resource`.\r\n\r\nFor example:\r\n\r\n```ruby\r\nclass ContactResource < JSONAPI::Resource\r\nend\r\n```\r\n\r\nA jsonapi-resource generator is available\r\n```\r\nrails generate jsonapi:resource contact\r\n```\r\n\r\n##### Abstract Resources\r\n\r\nResources that are not backed by a model (purely used as base classes for other resources) should be declared as\r\nabstract.\r\n\r\nBecause abstract resources do not expect to be backed by a model, they won't attempt to discover the model class\r\nor any of its relationships.\r\n\r\n```ruby\r\nclass BaseResource < JSONAPI::Resource\r\n  abstract\r\n\r\n  has_one :creator\r\nend\r\n\r\nclass ContactResource < BaseResource\r\nend\r\n```\r\n\r\n##### Immutable Resources\r\n\r\nResources that are immutable should be declared as such with the `immutable` method. Immutable resources will only\r\ngenerate routes for `index`, `show` and `show_relationship`.\r\n\r\n###### Immutable for Readonly\r\n\r\nSome resources are read-only and are not to be modified through the API. Declaring a resource as immutable prevents\r\ncreation of routes that allow modification of the resource.\r\n\r\n###### Immutable Heterogeneous Collections\r\n\r\nImmutable resources can be used as the basis for a heterogeneous collection. Resources in heterogeneous collections can\r\nstill be mutated through their own type-specific endpoints.\r\n\r\n```ruby\r\nclass VehicleResource < JSONAPI::Resource\r\n  immutable\r\n\r\n  has_one :owner\r\n  attributes :make, :model, :serial_number\r\nend\r\n\r\nclass CarResource < VehicleResource\r\n  attributes :drive_layout\r\n  has_one :driver\r\nend\r\n\r\nclass BoatResource < VehicleResource\r\n  attributes :length_at_water_line\r\n  has_one :captain\r\nend\r\n\r\n# routes\r\n  jsonapi_resources :vehicles\r\n  jsonapi_resources :cars\r\n  jsonapi_resources :boats\r\n\r\n```\r\n\r\nIn the above example vehicles are immutable. A call to `/vehicles` or `/vehicles/1` will return vehicles with types\r\nof either `car` or `boat`. But calls to PUT or POST a `car` must be made to `/cars`. The rails models backing the above\r\ncode use Single Table Inheritance.\r\n\r\n#### Context\r\n\r\nSometimes you will want to access things such as the current logged in user (and other state only available within your controllers) from within your resource classes. To make this state available to a resource class you need to put it into the context hash - this can be done via a `context` method on one of your controllers or across all controllers using ApplicationController.\r\n\r\nFor example:\r\n\r\n```ruby\r\nclass ApplicationController < JSONAPI::ResourceController\r\n  def context\r\n    {current_user: current_user}\r\n  end\r\nend\r\n\r\n# Specific resource controllers derive from ApplicationController\r\n# and share its context\r\nclass PeopleController < ApplicationController\r\n\r\nend\r\n\r\n# Assuming you don't permit user_id (so the client won't assign a wrong user to own the object)\r\n# you can ensure the current user is assigned the record by using the controller's context hash.\r\nclass PeopleResource < JSONAPI::Resource\r\n  before_save do\r\n    @model.user_id = context[:current_user].id if @model.new_record?\r\n  end\r\nend\r\n```\r\n\r\nYou can put things that affect serialization and resource configuration into the context.\r\n\r\n#### Attributes\r\n\r\nAny of a resource's attributes that are accessible must be explicitly declared. Single attributes can be declared using\r\nthe `attribute` method, and multiple attributes can be declared with the `attributes` method on the resource class.\r\n\r\nFor example:\r\n\r\n```ruby\r\nclass ContactResource < JSONAPI::Resource\r\n  attribute :name_first\r\n  attributes :name_last, :email, :twitter\r\nend\r\n```\r\n\r\nThis resource has 4 defined attributes: `name_first`, `name_last`, `email`, `twitter`, as well as the automatically\r\ndefined attributes `id` and `type`. By default these attributes must exist on the model that is handled by the resource.\r\n\r\nA resource object wraps a Ruby object, usually an `ActiveModel` record, which is available as the `@model` variable.\r\nThis allows a resource's methods to access the underlying model.\r\n\r\nFor example, a computed attribute for `full_name` could be defined as such:\r\n\r\n```ruby\r\nclass ContactResource < JSONAPI::Resource\r\n  attributes :name_first, :name_last, :email, :twitter\r\n  attribute :full_name\r\n\r\n  def full_name\r\n    \"#{@model.name_first}, #{@model.name_last}\"\r\n  end\r\nend\r\n```\r\n\r\n##### Attribute Delegation\r\n\r\nNormally resource attributes map to an attribute on the model of the same name. Using the `delegate` option allows a resource\r\nattribute to map to a differently named model attribute. For example:\r\n\r\n```ruby\r\nclass ContactResource < JSONAPI::Resource\r\n  attribute :name_first, delegate: :first_name\r\n  attribute :name_last, delegate: :last_name\r\nend\r\n```\r\n\r\n##### Fetchable Attributes\r\n\r\nBy default all attributes are assumed to be fetchable. The list of fetchable attributes can be filtered by overriding\r\nthe `fetchable_fields` method.\r\n\r\nHere's an example that prevents guest users from seeing the `email` field:\r\n\r\n```ruby\r\nclass AuthorResource < JSONAPI::Resource\r\n  attributes :name, :email\r\n  model_name 'Person'\r\n  has_many :posts\r\n\r\n  def fetchable_fields\r\n    if (context[:current_user].guest)\r\n      super - [:email]\r\n    else\r\n      super\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nContext flows through from the controller to the resource and can be used to control the attributes based on the\r\ncurrent user (or other value).\r\n\r\n##### Creatable and Updatable Attributes\r\n\r\nBy default all attributes are assumed to be updatable and creatable. To prevent some attributes from being accepted by\r\nthe `update` or `create` methods, override the `self.updatable_fields` and `self.creatable_fields` methods on a resource.\r\n\r\nThis example prevents `full_name` from being set:\r\n\r\n```ruby\r\nclass ContactResource < JSONAPI::Resource\r\n  attributes :name_first, :name_last, :full_name\r\n\r\n  def full_name\r\n    \"#{@model.name_first}, #{@model.name_last}\"\r\n  end\r\n\r\n  def self.updatable_fields(context)\r\n    super - [:full_name]\r\n  end\r\n\r\n  def self.creatable_fields(context)\r\n    super - [:full_name]\r\n  end\r\nend\r\n```\r\n\r\nThe `context` is not by default used by the `ResourceController`, but may be used if you override the controller methods.\r\nBy using the context you have the option to determine the creatable and updatable fields based on the user.\r\n\r\n##### Sortable Attributes\r\n\r\nJR supports [sorting primary resources by multiple sort criteria](http://jsonapi.org/format/#fetching-sorting).\r\n\r\nBy default all attributes are assumed to be sortable. To prevent some attributes from being sortable, override the\r\n`self.sortable_fields` method on a resource.\r\n\r\nHere's an example that prevents sorting by post's `body`:\r\n\r\n```ruby\r\nclass PostResource < JSONAPI::Resource\r\n  attributes :title, :body\r\n\r\n  def self.sortable_fields(context)\r\n    super(context) - [:body]\r\n  end\r\nend\r\n```\r\n\r\nJR also supports sorting primary resources by fields on relationships.\r\n\r\nHere's an example of sorting books by the author name:\r\n\r\n```ruby\r\nclass Book < ActiveRecord::Base\r\n    belongs_to :author\r\nend\r\n\r\nclass Author < ActiveRecord::Base\r\n    has_many :books\r\nend\r\n\r\nclass BookResource < JSONAPI::Resource\r\n  attributes :title, :body\r\n\r\n  def self.sortable_fields(context)\r\n    super(context) << :\"author.name\"\r\n   end\r\nend\r\n```\r\nThe request will look something like:\r\n```\r\nGET /books?include=author&sort=author.name\r\n```\r\n\r\n###### Default sorting\r\n\r\nBy default JR sorts ascending on the `id` of the primary resource, unless the request specifies an alternate sort order.\r\nTo override this you may override the `self.default_sort` on a `resource`. `default_sort` should return an array of\r\n`sort_param` hashes. A `sort_param` hash contains a `field` and a `direction`, with `direction` being either `:asc` or\r\n`:desc`.\r\n\r\nFor example:\r\n\r\n```ruby\r\n  def self.default_sort\r\n    [{field: 'name_last', direction: :desc}, {field: 'name_first', direction: :desc}]\r\n  end\r\n```\r\n\r\n##### Attribute Formatting\r\n\r\nAttributes can have a `Format`. By default all attributes use the default formatter. If an attribute has the `format`\r\noption set the system will attempt to find a formatter based on this name. In the following example the `last_login_time`\r\nwill be returned formatted to a certain time zone:\r\n\r\n```ruby\r\nclass PersonResource < JSONAPI::Resource\r\n  attributes :name, :email\r\n  attribute :last_login_time, format: :date_with_timezone\r\nend\r\n```\r\n\r\nThe system will lookup a value formatter named `DateWithTimezoneValueFormatter` and will use this when serializing and\r\nupdating the attribute. See the [Value Formatters](#value-formatters) section for more details.\r\n\r\n##### Flattening a Rails relationship\r\n\r\nIt is possible to flatten Rails relationships into attributes by using getters and setters. This can become handy if a relation needs to be created alongside the creation of the main object which can be the case if there is a bi-directional presence validation. For example:\r\n\r\n```ruby\r\n# Given Models\r\nclass Person < ActiveRecord::Base\r\n  has_many :spoken_languages\r\n  validates :name, :email, :spoken_languages, presence: true\r\nend\r\n\r\nclass SpokenLanguage < ActiveRecord::Base\r\n  belongs_to :person, inverse_of: :spoken_languages\r\n  validates :person, :language_code, presence: true\r\nend\r\n\r\n# Resource with getters and setter\r\nclass PersonResource < JSONAPI::Resource\r\n  attributes :name, :email, :spoken_languages\r\n\r\n  # Getter\r\n  def spoken_languages\r\n    @model.spoken_languages.pluck(:language_code)\r\n  end\r\n\r\n  # Setter (because spoken_languages needed for creation)\r\n  def spoken_languages=(new_spoken_language_codes)\r\n    @model.spoken_languages.destroy_all\r\n    new_spoken_language_codes.each do |new_lang_code|\r\n      @model.spoken_languages.build(language_code: new_lang_code)\r\n    end\r\n  end\r\nend\r\n```\r\n\r\n#### Primary Key\r\n\r\nResources are always represented using a key of `id`. The resource will interrogate the model to find the primary key.\r\nIf the underlying model does not use `id` as the primary key _and_ does not support the `primary_key` method you\r\nmust use the `primary_key` method to tell the resource which field on the model to use as the primary key. **Note:**\r\nthis _must_ be the actual primary key of the model.\r\n\r\nBy default only integer values are allowed for primary key. To change this behavior you can set the `resource_key_type`\r\nconfiguration option:\r\n\r\n```ruby\r\nJSONAPI.configure do |config|\r\n  # Allowed values are :integer(default), :uuid, :string, or a proc\r\n  config.resource_key_type = :uuid\r\nend\r\n```\r\n\r\n##### Override key type on a resource\r\n\r\nYou can override the default resource key type on a per-resource basis by calling `key_type` in the resource class,\r\nwith the same allowed values as the `resource_key_type` configuration option.\r\n\r\n```ruby\r\nclass ContactResource < JSONAPI::Resource\r\n  attribute :id\r\n  attributes :name_first, :name_last, :email, :twitter\r\n  key_type :uuid\r\nend\r\n```\r\n\r\n##### Custom resource key validators\r\n\r\nIf you need more control over the key, you can override the #verify_key method on your resource, or set a lambda that\r\naccepts key and context arguments in `config/initializers/jsonapi_resources.rb`:\r\n\r\n```ruby\r\nJSONAPI.configure do |config|\r\n  config.resource_key_type = -> (key, context) { key && String(key) }\r\nend\r\n```\r\n\r\n#### Model Name\r\n\r\nThe name of the underlying model is inferred from the Resource name. It can be overridden by use of the `model_name`\r\nmethod. For example:\r\n\r\n```ruby\r\nclass AuthorResource < JSONAPI::Resource\r\n  attribute :name\r\n  model_name 'Person'\r\n  has_many :posts\r\nend\r\n```\r\n\r\n#### Model Hints\r\n\r\nResource instances are created from model records. The determination of the correct resource type is performed using a\r\nsimple rule based on the model's name. The name is used to find a resource in the same module (as the originating\r\nresource) that matches the name. This usually works quite well, however it can fail when model names do not match\r\nresource names. It can also fail when using namespaced models. In this case a `model_hint` can be created to map model\r\nnames to resources. For example:\r\n\r\n```ruby\r\nclass AuthorResource < JSONAPI::Resource\r\n  attribute :name\r\n  model_name 'Person'\r\n  model_hint model: Commenter, resource: :special_person\r\n\r\n  has_many :posts\r\n  has_many :commenters\r\nend\r\n```\r\n\r\nNote that when `model_name` is set a corresponding `model_hint` is also added. This can be skipped by using the\r\n`add_model_hint` option set to false. For example:\r\n\r\n```ruby\r\nclass AuthorResource < JSONAPI::Resource\r\n  model_name 'Legacy::Person', add_model_hint: false\r\nend\r\n```\r\n\r\nModel hints inherit from parent resources, but are not global in scope. The `model_hint` method accepts `model` and\r\n`resource` named parameters. `model` takes an ActiveRecord class or class name (defaults to the model name), and\r\n`resource` takes a resource type or a resource class (defaults to the current resource's type).\r\n\r\n#### Relationships\r\n\r\nRelated resources need to be specified in the resource. These may be declared with the `relationship` or the `has_one`\r\nand the `has_many` methods.\r\n\r\nHere's a simple example using the `relationship` method where a post has a single author and an author can have many\r\nposts:\r\n\r\n```ruby\r\nclass PostResource < JSONAPI::Resource\r\n  attributes :title, :body\r\n\r\n  relationship :author, to: :one\r\nend\r\n```\r\n\r\nAnd the corresponding author:\r\n\r\n```ruby\r\nclass AuthorResource < JSONAPI::Resource\r\n  attribute :name\r\n\r\n  relationship :posts, to: :many\r\nend\r\n```\r\n\r\nAnd here's the equivalent resources using the `has_one` and `has_many` methods:\r\n\r\n```ruby\r\nclass PostResource < JSONAPI::Resource\r\n  attributes :title, :body\r\n\r\n  has_one :author\r\nend\r\n```\r\n\r\nAnd the corresponding author:\r\n\r\n```ruby\r\nclass AuthorResource < JSONAPI::Resource\r\n  attribute :name\r\n\r\n  has_many :posts\r\nend\r\n```\r\n\r\n##### Options\r\n\r\nThe relationship methods (`relationship`, `has_one`, and `has_many`) support the following options:\r\n\r\n * `class_name` - a string specifying the underlying class for the related resource. Defaults to the `class_name` property on the underlying model.\r\n * `foreign_key` - the method on the resource used to fetch the related resource. Defaults to `<resource_name>_id` for has_one and `<resource_name>_ids` for has_many relationships.\r\n * `acts_as_set` - allows the entire set of related records to be replaced in one operation. Defaults to false if not set.\r\n * `polymorphic` - set to true to identify relationships that are polymorphic.\r\n * `relation_name` - the name of the relation to use on the model. A lambda may be provided which allows conditional selection of the relation based on the context.\r\n * `always_include_linkage_data` - if set to true, the relationship includes linkage data. Defaults to false if not set.\r\n * `eager_load_on_include` - if set to false, will not include this relationship in join SQL when requested via an include. You usually want to leave this on, but it will break 'relationships' which are not active record, for example if you want to expose a tree using the `ancestry` gem or similar, or the SQL query becomes too large to handle. Defaults to true if not set.\r\n\r\n`to_one` relationships support the additional option:\r\n * `foreign_key_on` - defaults to `:self`. To indicate that the foreign key is on the related resource specify `:related`.\r\n\r\n`to_many` relationships support the additional option:\r\n * `reflect` - defaults to `true`. To indicate that updates to the relationship are performed on the related resource, if relationship reflection is turned on. See [Configuration] (#configuration)\r\n\r\nExamples:\r\n\r\n```ruby\r\nclass CommentResource < JSONAPI::Resource\r\n  attributes :body\r\n  has_one :post\r\n  has_one :author, class_name: 'Person'\r\n  has_many :tags, acts_as_set: true\r\nend\r\n\r\nclass ExpenseEntryResource < JSONAPI::Resource\r\n  attributes :cost, :transaction_date\r\n\r\n  has_one :currency, class_name: 'Currency', foreign_key: 'currency_code'\r\n  has_one :employee\r\nend\r\n\r\nclass TagResource < JSONAPI::Resource\r\n  attributes :name\r\n  has_one :taggable, polymorphic: true\r\nend\r\n```\r\n\r\n```ruby\r\nclass BookResource < JSONAPI::Resource\r\n\r\n  # Only book_admins may see unapproved comments for a book. Using\r\n  # a lambda to select the correct relation on the model\r\n  has_many :book_comments, relation_name: -> (options = {}) {\r\n    context = options[:context]\r\n    current_user = context ? context[:current_user] : nil\r\n\r\n    unless current_user && current_user.book_admin\r\n      :approved_book_comments\r\n    else\r\n      :book_comments\r\n    end\r\n  }\r\n  ...\r\nend\r\n```\r\n\r\nThe polymorphic relationship will require the resource and controller to exist, although routing to them will cause an\r\nerror.\r\n\r\n```ruby\r\nclass TaggableResource < JSONAPI::Resource; end\r\nclass TaggablesController < JSONAPI::ResourceController; end\r\n```\r\n\r\n#### Filters\r\n\r\nFilters for locating objects of the resource type are specified in the resource definition. Single filters can be\r\ndeclared using the `filter` method, and multiple filters can be declared with the `filters` method on the resource\r\nclass.\r\n\r\nFor example:\r\n\r\n```ruby\r\nclass ContactResource < JSONAPI::Resource\r\n  attributes :name_first, :name_last, :email, :twitter\r\n\r\n  filter :id\r\n  filters :name_first, :name_last\r\nend\r\n```\r\n\r\nThen a request could pass in a filter for example `http://example.com/contacts?filter[name_last]=Smith` and the system\r\nwill find all people where the last name exactly matches Smith.\r\n\r\n##### Default Filters\r\n\r\nA default filter may be defined for a resource using the `default` option on the `filter` method. This default is used\r\nunless the request overrides this value.\r\n\r\nFor example:\r\n\r\n```ruby\r\n class CommentResource < JSONAPI::Resource\r\n  attributes :body, :status\r\n  has_one :post\r\n  has_one :author\r\n\r\n  filter :status, default: 'published,pending'\r\nend\r\n```\r\n\r\nThe default value is used as if it came from the request.\r\n\r\n##### Applying Filters\r\n\r\nYou may customize how a filter behaves by supplying a callable to the `:apply` option. This callable will be used to\r\napply that filter. The callable is passed the `records`, which is an `ActiveRecord::Relation`, the `value`, and an\r\n`_options` hash. It is expected to return an `ActiveRecord::Relation`.\r\n\r\nNote: When a filter is not supplied a `verify` callable to modify the `value` that the `apply` callable receives,\r\n`value` defaults to an array of the string values provided to the filter parameter.\r\n\r\nThis example shows how you can implement different approaches for different filters.\r\n\r\n```ruby\r\n# When given the following parameter:'filter[visibility]': 'public'\r\n\r\nfilter :visibility, apply: ->(records, value, _options) {\r\n  records.where('users.publicly_visible = ?', value[0] == 'public')\r\n}\r\n```\r\n\r\nIf you omit the `apply` callable the filter will be applied as `records.where(filter => value)`.\r\n\r\nNote: It is also possible to override the `self.apply_filter` method, though this approach is now deprecated:\r\n\r\n```ruby\r\ndef self.apply_filter(records, filter, value, options)\r\n  case filter\r\n    when :last_name, :first_name, :name\r\n      if value.is_a?(Array)\r\n        value.each do |val|\r\n          records = records.where(_model_class.arel_table[filter].matches(val))\r\n        end\r\n        records\r\n      else\r\n        records.where(_model_class.arel_table[filter].matches(value))\r\n      end\r\n    else\r\n      super(records, filter, value)\r\n  end\r\nend\r\n```\r\n\r\n##### Verifying Filters\r\n\r\nBecause filters typically come straight from the request, it's prudent to verify their values. To do so, provide a\r\ncallable to the `verify` option. This callable will be passed the `value` and the `context`. Verify should return the\r\nverified value, which may be modified.\r\n\r\n```ruby\r\n  filter :ids,\r\n    verify: ->(values, context) {\r\n      verify_keys(values, context)\r\n      values\r\n    },\r\n    apply: ->(records, value, _options) {\r\n      records.where('id IN (?)', value)\r\n    }\r\n```\r\n\r\n```ruby\r\n# A more complex example, showing how to filter for any overlap between the\r\n# value array and the possible_ids, using both verify and apply callables.\r\n\r\n  filter :possible_ids,\r\n    verify: ->(values, context) {\r\n      values.map {|value| value.to_i}\r\n    },\r\n    apply: ->(records, value, _options) {\r\n      records.where('possible_ids && ARRAY[?]', value)\r\n    }\r\n```\r\n\r\n##### Finders\r\n\r\nBasic finding by filters is supported by resources. This is implemented in the `find` and `find_by_key` finder methods.\r\nCurrently this is implemented for `ActiveRecord` based resources. The finder methods rely on the `records` method to get\r\nan `ActiveRecord::Relation` relation. It is therefore possible to override `records` to affect the three find related\r\nmethods.\r\n\r\n###### Customizing base records for finder methods\r\n\r\nIf you need to change the base records on which `find` and `find_by_key` operate, you can override the `records` method\r\non the resource class.\r\n\r\nFor example to allow a user to only retrieve his own posts you can do the following:\r\n\r\n```ruby\r\nclass PostResource < JSONAPI::Resource\r\n  attributes :title, :body\r\n\r\n  def self.records(options = {})\r\n    context = options[:context]\r\n    context[:current_user].posts\r\n  end\r\nend\r\n```\r\n\r\nWhen you create a relationship, a method is created to fetch record(s) for that relationship, using the relation name\r\nfor the relationship.\r\n\r\n```ruby\r\nclass PostResource < JSONAPI::Resource\r\n  has_one :author\r\n  has_many :comments\r\n\r\n  # def record_for_author\r\n  #   relationship = self.class._relationship(:author)\r\n  #   relation_name = relationship.relation_name(context: @context)\r\n  #   records_for(relation_name)\r\n  # end\r\n\r\n  # def records_for_comments\r\n  #   relationship = self.class._relationship(:comments)\r\n  #   relation_name = relationship.relation_name(context: @context)\r\n  #   records_for(relation_name)\r\n  # end\r\nend\r\n\r\n```\r\n\r\nFor example, you may want to raise an error if the user is not authorized to view the related records. See the next\r\nsection for additional details on raising errors.\r\n\r\n```ruby\r\nclass BaseResource < JSONAPI::Resource\r\n  def records_for(relation_name)\r\n    context = options[:context]\r\n    records = _model.public_send(relation_name)\r\n\r\n    unless context[:current_user].can_view?(records)\r\n      raise NotAuthorizedError\r\n    end\r\n\r\n    records\r\n  end\r\nend\r\n```\r\n\r\n###### Raising Errors\r\n\r\nInside the finder methods (like `records_for`) or inside of resource callbacks\r\n(like `before_save`) you can `raise` an error to halt processing. JSONAPI::Resources\r\nhas some built in errors that will return appropriate error codes. By\r\ndefault any other error that you raise will return a `500` status code\r\nfor a general internal server error.\r\n\r\nTo return useful error codes that represent application errors you\r\nshould set the `exception_class_whitelist` config variable, and then you\r\nshould use the Rails `rescue_from` macro to render a status code.\r\n\r\nFor example, this config setting allows the `NotAuthorizedError` to bubble up out of\r\nJSONAPI::Resources and into your application.\r\n\r\n```ruby\r\n# config/initializer/jsonapi-resources.rb\r\nJSONAPI.configure do |config|\r\n  config.exception_class_whitelist = [NotAuthorizedError]\r\nend\r\n```\r\n\r\nHandling the error and rendering the appropriate code is now the resonsiblity of the\r\napplication and could be handled like this:\r\n\r\n```ruby\r\nclass ApiController < ApplicationController\r\n  rescue_from NotAuthorizedError, with: :reject_forbidden_request\r\n  def reject_forbidden_request\r\n    render json: {error: 'Forbidden'}, :status => 403\r\n  end\r\nend\r\n```\r\n\r\n\r\n###### Applying Filters\r\n\r\nThe `apply_filter` method is called to apply each filter to the `Arel` relation. You may override this method to gain\r\ncontrol over how the filters are applied to the `Arel` relation.\r\n\r\nThis example shows how you can implement different approaches for different filters.\r\n\r\n```ruby\r\ndef self.apply_filter(records, filter, value, options)\r\n  case filter\r\n    when :visibility\r\n      records.where('users.publicly_visible = ?', value == :public)\r\n    when :last_name, :first_name, :name\r\n      if value.is_a?(Array)\r\n        value.each do |val|\r\n          records = records.where(_model_class.arel_table[filter].matches(val))\r\n        end\r\n        records\r\n      else\r\n        records.where(_model_class.arel_table[filter].matches(value))\r\n      end\r\n    else\r\n      super(records, filter, value)\r\n  end\r\nend\r\n```\r\n\r\n\r\n###### Applying Sorting\r\n\r\nYou can override the `apply_sort` method to gain control over how the sorting is done. This may be useful in case you'd\r\nlike to base the sorting on variables in your context.\r\n\r\nExample:\r\n\r\n```ruby\r\ndef self.apply_sort(records, order_options, context = {})\r\n  if order_options.has?(:trending)\r\n    records = records.order_by_trending_scope\r\n    order_options - [:trending]\r\n  end\r\n\r\n  super(records, order_options, context)\r\nend\r\n```\r\n\r\n\r\n###### Override finder methods\r\n\r\nFinally if you have more complex requirements for finding you can override the `find` and `find_by_key` methods on the\r\nresource class.\r\n\r\nHere's an example that defers the `find` operation to a `current_user` set on the `context` option:\r\n\r\n```ruby\r\nclass AuthorResource < JSONAPI::Resource\r\n  attribute :name\r\n  model_name 'Person'\r\n  has_many :posts\r\n\r\n  filter :name\r\n\r\n  def self.find(filters, options = {})\r\n    context = options[:context]\r\n    authors = context[:current_user].find_authors(filters)\r\n\r\n    return authors.map do |author|\r\n      self.new(author, context)\r\n    end\r\n  end\r\nend\r\n```\r\n\r\n#### Pagination\r\n\r\nPagination is performed using a `paginator`, which is a class responsible for parsing the `page` request parameters and\r\napplying the pagination logic to the results.\r\n\r\n##### Paginators\r\n\r\n`JSONAPI::Resource` supports several pagination methods by default, and allows you to implement a custom system if the\r\ndefaults do not meet your needs.\r\n\r\n###### Paged Paginator\r\n\r\nThe `paged` `paginator` returns results based on pages of a fixed size. Valid `page` parameters are `number` and `size`.\r\nIf `number` is omitted the first page is returned. If `size` is omitted the `default_page_size` from the configuration\r\nsettings is used.\r\n\r\n```\r\nGET /articles?page%5Bnumber%5D=10&page%5Bsize%5D=10 HTTP/1.1\r\nAccept: application/vnd.api+json\r\n```\r\n\r\n###### Offset Paginator\r\n\r\nThe `offset` `paginator` returns results based on an offset from the beginning of the resultset. Valid `page` parameters\r\nare `offset` and `limit`. If `offset` is omitted a value of 0 will be used. If `limit` is omitted the `default_page_size`\r\nfrom the configuration settings is used.\r\n\r\n```\r\nGET /articles?page%5Blimit%5D=10&page%5Boffset%5D=10 HTTP/1.1\r\nAccept: application/vnd.api+json\r\n```\r\n\r\n###### Custom Paginators\r\n\r\nCustom `paginators` can be used. These should derive from `Paginator`. The `apply` method takes a `relation` and\r\n`order_options` and is expected to return a `relation`. The `initialize` method receives the parameters from the `page`\r\nrequest parameters. It is up to the paginator author to parse and validate these parameters.\r\n\r\nFor example, here is a very simple single record at a time paginator:\r\n\r\n```ruby\r\nclass SingleRecordPaginator < JSONAPI::Paginator\r\n  def initialize(params)\r\n    # param parsing and validation here\r\n    @page = params.to_i\r\n  end\r\n\r\n  def apply(relation, order_options)\r\n    relation.offset(@page).limit(1)\r\n  end\r\nend\r\n```\r\n\r\n##### Paginator Configuration\r\n\r\nThe default paginator, which will be used for all resources, is set using `JSONAPI.configure`. For example, in your\r\n`config/initializers/jsonapi_resources.rb`:\r\n\r\n```ruby\r\nJSONAPI.configure do |config|\r\n  # built in paginators are :none, :offset, :paged\r\n  config.default_paginator = :offset\r\n\r\n  config.default_page_size = 10\r\n  config.maximum_page_size = 20\r\nend\r\n```\r\n\r\nIf no `default_paginator` is configured, pagination will be disabled by default.\r\n\r\nPaginators can also be set at the resource-level, which will override the default setting. This is done using the\r\n`paginator` method:\r\n\r\n```ruby\r\nclass BookResource < JSONAPI::Resource\r\n  attribute :title\r\n  attribute :isbn\r\n\r\n  paginator :offset\r\nend\r\n```\r\n\r\nTo disable pagination in a resource, specify `:none` for `paginator`.\r\n\r\n#### Included relationships (side-loading resources)\r\n\r\nJR supports [request include params](http://jsonapi.org/format/#fetching-includes) out of the box, for side loading related resources.\r\n\r\nHere's an example from the spec:\r\n\r\n```\r\nGET /articles/1?include=comments HTTP/1.1\r\nAccept: application/vnd.api+json\r\n```\r\n\r\nWill get you the following payload by default:\r\n\r\n```\r\n{\r\n  \"data\": {\r\n    \"type\": \"articles\",\r\n    \"id\": \"1\",\r\n    \"attributes\": {\r\n      \"title\": \"JSON API paints my bikeshed!\"\r\n    },\r\n    \"links\": {\r\n      \"self\": \"http://example.com/articles/1\"\r\n    },\r\n    \"relationships\": {\r\n      \"comments\": {\r\n        \"links\": {\r\n          \"self\": \"http://example.com/articles/1/relationships/comments\",\r\n          \"related\": \"http://example.com/articles/1/comments\"\r\n        },\r\n        \"data\": [\r\n          { \"type\": \"comments\", \"id\": \"5\" },\r\n          { \"type\": \"comments\", \"id\": \"12\" }\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"included\": [{\r\n    \"type\": \"comments\",\r\n    \"id\": \"5\",\r\n    \"attributes\": {\r\n      \"body\": \"First!\"\r\n    },\r\n    \"links\": {\r\n      \"self\": \"http://example.com/comments/5\"\r\n    }\r\n  }, {\r\n    \"type\": \"comments\",\r\n    \"id\": \"12\",\r\n    \"attributes\": {\r\n      \"body\": \"I like XML better\"\r\n    },\r\n    \"links\": {\r\n      \"self\": \"http://example.com/comments/12\"\r\n    }\r\n  }]\r\n}\r\n```\r\n\r\n#### Resource Meta\r\n\r\nMeta information can be included for each resource using the meta method in the resource declaration. For example:\r\n\r\n```ruby\r\nclass BookResource < JSONAPI::Resource\r\n  attribute :title\r\n  attribute :isbn\r\n\r\n  def meta(options)\r\n    {\r\n      copyright: 'API Copyright 2015 - XYZ Corp.',\r\n      computed_copyright: options[:serialization_options][:copyright],\r\n      last_updated_at: _model.updated_at\r\n    }\r\n   end\r\nend\r\n\r\n```\r\n\r\nThe `meta` method will be called for each resource instance. Override the `meta` method on a resource class to control\r\nthe meta information for the resource. If a non empty hash is returned from `meta` this will be serialized. The `meta`\r\nmethod is called with an `options` hash. The `options` hash will contain the following:\r\n\r\n * `:serializer` -> the serializer instance\r\n * `:serialization_options` -> the contents of the `serialization_options` method on the controller.\r\n\r\n#### Custom Links\r\n\r\nCustom links can be included for each resource by overriding the `custom_links` method. If a non empty hash is returned from `custom_links`, it will be merged with the default links hash containing the resource's `self` link. The `custom_links` method is called with the same `options` hash used by for [resource meta information](#resource-meta). The `options` hash contains the following:\r\n\r\n * `:serializer` -> the serializer instance\r\n * `:serialization_options` -> the contents of the `serialization_options` method on the controller.\r\n\r\nFor example:\r\n\r\n```ruby\r\nclass CityCouncilMeeting < JSONAPI::Resource\r\n  attribute :title, :location, :approved\r\n\r\n  def custom_links(options)\r\n    { minutes: options[:serializer].link_builder.self_link(self) + \"/minutes\" }\r\n  end\r\nend\r\n```\r\n\r\nThis will create a custom link with the key `minutes`, which will be merged with the default `self` link, like so:\r\n\r\n```json\r\n{\r\n  \"data\": [\r\n    {\r\n      \"id\": \"1\",\r\n      \"type\": \"cityCouncilMeetings\",\r\n      \"links\": {\r\n        \"self\": \"http://city.gov/api/city-council-meetings/1\",\r\n        \"minutes\": \"http://city.gov/api/city-council-meetings/1/minutes\"\r\n      },\r\n      \"attributes\": {...}\r\n    },\r\n    //...\r\n  ]\r\n}\r\n```\r\n\r\nOf course, the `custom_links` method can include logic to include links only when relevant:\r\n\r\n````ruby\r\nclass CityCouncilMeeting < JSONAPI::Resource\r\n  attribute :title, :location, :approved\r\n\r\n  delegate :approved?, to: :model\r\n\r\n  def custom_links(options)\r\n    extra_links = {}\r\n    if approved?\r\n      extra_links[:minutes] = options[:serializer].link_builder.self_link(self) + \"/minutes\"\r\n    end\r\n    extra_links\r\n  end\r\nend\r\n```\r\n\r\nIt's also possibly to suppress the default `self` link by returning a hash with `{self: nil}`:\r\n\r\n````ruby\r\nclass Selfless < JSONAPI::Resource\r\n  def custom_links(options)\r\n    {self: nil}\r\n  end\r\nend\r\n```\r\n\r\n#### Callbacks\r\n\r\n`ActiveSupport::Callbacks` is used to provide callback functionality, so the behavior is very similar to what you may be\r\nused to from `ActiveRecord`.\r\n\r\nFor example, you might use a callback to perform authorization on your resource before an action.\r\n\r\n```ruby\r\nclass BaseResource < JSONAPI::Resource\r\n  before_create :authorize_create\r\n\r\n  def authorize_create\r\n    # ...\r\n  end\r\nend\r\n```\r\n\r\nThe types of supported callbacks are:\r\n- `before`\r\n- `after`\r\n- `around`\r\n\r\n##### `JSONAPI::Resource` Callbacks\r\n\r\nCallbacks can be defined for the following `JSONAPI::Resource` events:\r\n\r\n- `:create`\r\n- `:update`\r\n- `:remove`\r\n- `:save`\r\n- `:create_to_many_link`\r\n- `:replace_to_many_links`\r\n- `:create_to_one_link`\r\n- `:replace_to_one_link`\r\n- `:remove_to_many_link`\r\n- `:remove_to_one_link`\r\n- `:replace_fields`\r\n\r\n###### Relationship Reflection\r\n\r\nBy default updates to relationships only invoke callbacks on the primary\r\nResource. By setting the `use_relationship_reflection` [Configuration] (#configuration) option\r\nupdates to `has_many` relationships will occur on the related resource, triggering\r\ncallbacks on both resources.\r\n\r\n##### `JSONAPI::Processor` Callbacks\r\n\r\nCallbacks can also be defined for `JSONAPI::Processor` events:\r\n- `:operation`: Any individual operation.\r\n- `:find`: A `find` operation is being processed.\r\n- `:show`: A `show` operation is being processed.\r\n- `:show_relationship`: A `show_relationship` operation is being processed.\r\n- `:show_related_resource`: A `show_related_resource` operation is being processed.\r\n- `:show_related_resources`: A `show_related_resources` operation is being processed.\r\n- `:create_resource`: A `create_resource` operation is being processed.\r\n- `:remove_resource`: A `remove_resource` operation is being processed.\r\n- `:replace_fields`: A `replace_fields` operation is being processed.\r\n- `:replace_to_one_relationship`: A `replace_to_one_relationship` operation is being processed.\r\n- `:create_to_many_relationship`: A `create_to_many_relationship` operation is being processed.\r\n- `:replace_to_many_relationship`: A `replace_to_many_relationship` operation is being processed.\r\n- `:remove_to_many_relationship`: A `remove_to_many_relationship` operation is being processed.\r\n- `:remove_to_one_relationship`: A `remove_to_one_relationship` operation is being processed.\r\n\r\nSee [Operation Processors] (#operation-processors) for details on using OperationProcessors\r\n\r\n##### `JSONAPI::OperationsProcessor` Callbacks (a removed feature)\r\n\r\nNote: The `JSONAPI::OperationsProcessor` has been removed and replaced with the `JSONAPI::OperationDispatcher`\r\nand `Processor` classes per resource. The callbacks have been renamed and moved to the\r\n`Processor`s, with the exception of the `operations` callback which is now on the controller.\r\n\r\n### Controllers\r\n\r\nThere are two ways to implement a controller for your resources. Either derive from `ResourceController` or import\r\nthe `ActsAsResourceController` module.\r\n\r\n##### ResourceController\r\n\r\n`JSONAPI::Resources` provides a class, `ResourceController`, that can be used as the base class for your controllers.\r\n`ResourceController` supports `index`, `show`, `create`, `update`, and `destroy` methods. Just deriving your controller\r\nfrom `ResourceController` will give you a fully functional controller.\r\n\r\nFor example:\r\n\r\n```ruby\r\nclass PeopleController < JSONAPI::ResourceController\r\n\r\nend\r\n```\r\n\r\nOf course you are free to extend this as needed and override action handlers or other methods.\r\n\r\nA jsonapi-controller generator is avaliable\r\n\r\n```\r\nrails generate jsonapi:controller contact\r\n```\r\n\r\n###### ResourceControllerMetal\r\n\r\n`JSONAPI::Resources` also provides an alternative class to `ResourceController` called `ResourceControllerMetal`.\r\nIn order to provide a lighter weight controller option this strips the controller down to just the classes needed\r\nto work with `JSONAPI::Resources`.\r\n\r\nFor example:\r\n\r\n```ruby\r\nclass PeopleController < JSONAPI::ResourceControllerMetal\r\n\r\nend\r\n```\r\n\r\nNote: This may not provide all of the expected controller capabilities if you are using additional gems such as DoorKeeper.\r\n\r\n###### Serialization Options\r\n\r\nAdditional options can be passed to the serializer using the `serialization_options` method.\r\n\r\nFor example:\r\n\r\n```ruby\r\nclass ApplicationController < JSONAPI::ResourceController\r\n  def serialization_options\r\n    {copyright: 'Copyright 2015'}\r\n  end\r\nend\r\n```\r\n\r\nThese `serialization_options` are passed to the `meta` method used to generate resource `meta` values.\r\n\r\n##### ActsAsResourceController\r\n\r\n`JSONAPI::Resources` also provides a module, `JSONAPI::ActsAsResourceController`. You can include this module to\r\nmix in all the features of `ResourceController` into your existing controller class.\r\n\r\nFor example:\r\n\r\n```ruby\r\nclass PostsController < ActionController::Base\r\n  include JSONAPI::ActsAsResourceController\r\nend\r\n```\r\n\r\n#### Namespaces\r\n\r\nJSONAPI::Resources supports namespacing of controllers and resources. With namespacing you can version your API.\r\n\r\nIf you namespace your controller it will require a namespaced resource.\r\n\r\nIn the following example we have a `resource` that isn't namespaced, and one that has now been namespaced. There are\r\nslight differences between the two resources, as might be seen in a new version of an API:\r\n\r\n```ruby\r\nclass PostResource < JSONAPI::Resource\r\n  attribute :title\r\n  attribute :body\r\n  attribute :subject\r\n\r\n  has_one :author, class_name: 'Person'\r\n  has_one :section\r\n  has_many :tags, acts_as_set: true\r\n  has_many :comments, acts_as_set: false\r\n  def subject\r\n    @model.title\r\n  end\r\n\r\n  filters :title, :author, :tags, :comments\r\n  filter :id\r\nend\r\n\r\n...\r\n\r\nmodule Api\r\n  module V1\r\n    class PostResource < JSONAPI::Resource\r\n      # V1 replaces the non-namespaced resource\r\n      # V1 no longer supports tags and now calls author 'writer'\r\n      attribute :title\r\n      attribute :body\r\n      attribute :subject\r\n\r\n      has_one :writer, foreign_key: 'author_id'\r\n      has_one :section\r\n      has_many :comments, acts_as_set: false\r\n\r\n      def subject\r\n        @model.title\r\n      end\r\n\r\n      filters :writer\r\n    end\r\n\r\n    class WriterResource < JSONAPI::Resource\r\n      attributes :name, :email\r\n      model_name 'Person'\r\n      has_many :posts\r\n\r\n      filter :name\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nThe following controllers are used:\r\n\r\n```ruby\r\nclass PostsController < JSONAPI::ResourceController\r\nend\r\n\r\nmodule Api\r\n  module V1\r\n    class PostsController < JSONAPI::ResourceController\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nYou will also need to namespace your routes:\r\n\r\n```ruby\r\nRails.application.routes.draw do\r\n\r\n  jsonapi_resources :posts\r\n\r\n  namespace :api do\r\n    namespace :v1 do\r\n      jsonapi_resources :posts\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nWhen a namespaced `resource` is used, any related `resources` must also be in the same namespace.\r\n\r\n#### Error codes\r\n\r\nError codes are provided for each error object returned, based on the error. These errors are:\r\n\r\n```ruby\r\nmodule JSONAPI\r\n  VALIDATION_ERROR = '100'\r\n  INVALID_RESOURCE = '101'\r\n  FILTER_NOT_ALLOWED = '102'\r\n  INVALID_FIELD_VALUE = '103'\r\n  INVALID_FIELD = '104'\r\n  PARAM_NOT_ALLOWED = '105'\r\n  PARAM_MISSING = '106'\r\n  INVALID_FILTER_VALUE = '107'\r\n  COUNT_MISMATCH = '108'\r\n  KEY_ORDER_MISMATCH = '109'\r\n  KEY_NOT_INCLUDED_IN_URL = '110'\r\n  INVALID_INCLUDE = '112'\r\n  RELATION_EXISTS = '113'\r\n  INVALID_SORT_CRITERIA = '114'\r\n  INVALID_LINKS_OBJECT = '115'\r\n  TYPE_MISMATCH = '116'\r\n  INVALID_PAGE_OBJECT = '117'\r\n  INVALID_PAGE_VALUE = '118'\r\n  INVALID_FIELD_FORMAT = '119'\r\n  INVALID_FILTERS_SYNTAX = '120'\r\n  SAVE_FAILED = '121'\r\n  FORBIDDEN = '403'\r\n  RECORD_NOT_FOUND = '404'\r\n  NOT_ACCEPTABLE = '406'\r\n  UNSUPPORTED_MEDIA_TYPE = '415'\r\n  LOCKED = '423'\r\nend\r\n```\r\n\r\nThese codes can be customized in your app by creating an initializer to override any or all of the codes.\r\n\r\nIn addition textual error codes can be returned by setting the configuration option `use_text_errors = true`. For\r\nexample:\r\n\r\n```ruby\r\nJSONAPI.configure do |config|\r\n  config.use_text_errors = true\r\nend\r\n```\r\n\r\n\r\n#### Handling Exceptions\r\n\r\nBy default, all exceptions raised downstream from a resource controller will be caught, logged, and a ```500 Internal Server Error``` will be rendered. Exceptions can be whitelisted in the config to pass through the handler and be caught manually, or you can pass a callback from a resource controller to insert logic into the rescue block without interrupting the control flow. This can be particularly useful for additional logging or monitoring without the added work of rendering responses.\r\n\r\nPass a block, refer to controller class methods, or both. Note that methods must be defined as class methods on a controller and accept one parameter, which is passed the exception object that was rescued.\r\n\r\n```ruby\r\n  class ApplicationController < JSONAPI::ResourceController\r\n\r\n    on_server_error :first_callback\r\n\r\n    #or\r\n\r\n    # on_server_error do |error|\r\n      #do things\r\n    #end\r\n\r\n    def self.first_callback(error)\r\n      #env[\"airbrake.error_id\"] = notify_airbrake(error)\r\n    end\r\n  end\r\n\r\n```\r\n\r\n#### Action Callbacks\r\n\r\n##### verify_content_type_header\r\n\r\nBy default, when controllers extend functionalities from `jsonapi-resources`, the `ActsAsResourceController#verify_content_type_header`\r\nmethod will be triggered before `create`, `update`, `create_relationship` and `update_relationship` actions. This method is reponsible\r\nfor checking if client's request corresponds to the correct media type required by [JSON API](http://jsonapi.org/format/#content-negotiation-clients): `application/vnd.api+json`.\r\n\r\nIn case you need to check the media type for custom actions, just make sure to call the method in your controller's `before_action`:\r\n\r\n```ruby\r\nclass UsersController < JSONAPI::ResourceController\r\n  before_action :verify_content_type_header, only: [:auth]\r\n\r\n  def auth\r\n    # some crazy auth code goes here\r\n  end\r\nend\r\n```\r\n\r\n### Operation Processors\r\n\r\nOperation Processors are called to perform the operation(s) that make up a request. The controller (through the `OperationDispatcher`), creates an `OperatorProcessor` to handle each operation. The processor is created based on the resource name, including the namespace. If a processor does not exist for a resource (namespace matters) the default operation processor is used instead. The default processor can be changed by a configuration setting.\r\n\r\nDefining a custom `Processor` allows for custom callback handling of each operation type for each resource type. For example:\r\n\r\n```ruby\r\nclass Api::V4::BookProcessor < JSONAPI::Processor\r\n  after_find do\r\n    unless @result.is_a?(JSONAPI::ErrorsOperationResult)\r\n      @result.meta[:total_records_found] = @result.record_count\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nThis simple example uses a callback to update the result's meta property with the total count of records (a redundant\r\nfeature only for example purposes), if there wasn't an error in the operation.  It is also possible to override the\r\n`find` method as well if a different behavior is needed, for example:\r\n\r\n```ruby\r\nclass Api::V4::BookProcessor < JSONAPI::Processor\r\n  def find\r\n    filters = params[:filters]\r\n    include_directives = params[:include_directives]\r\n    sort_criteria = params.fetch(:sort_criteria, [])\r\n    paginator = params[:paginator]\r\n\r\n    verified_filters = resource_klass.verify_filters(filters, context)\r\n    resource_records = resource_klass.find(verified_filters,\r\n                                           context: context,\r\n                                           include_directives: include_directives,\r\n                                           sort_criteria: sort_criteria,\r\n                                           paginator: paginator)\r\n\r\n    page_options = {}\r\n    # Overriding the default record count logic to always include it in the meta\r\n    #if (JSONAPI.configuration.top_level_meta_include_record_count ||\r\n    #  (paginator && paginator.class.requires_record_count))\r\n      page_options[:record_count] = resource_klass.find_count(verified_filters,\r\n                                                              context: context,\r\n                                                              include_directives: include_directives)\r\n    #end\r\nend\r\n```\r\n\r\nNote: The authors of this gem expect the most common uses cases to be handled using the callbacks. It is likely that the\r\ninternal functionality of the operation processing methods will change, at least for several revisions. Effort will be\r\nmade to call this out in release notes. You have been warned.\r\n\r\n### Serializer\r\n\r\nThe `ResourceSerializer` can be used to serialize a resource into JSON API compliant JSON. `ResourceSerializer` must be\r\n initialized with the primary resource type it will be serializing. `ResourceSerializer` has a `serialize_to_hash`\r\n method that takes a resource instance or array of resource instances to serialize. For example:\r\n\r\n```ruby\r\npost = Post.find(1)\r\nJSONAPI::ResourceSerializer.new(PostResource).serialize_to_hash(PostResource.new(post, nil))\r\n```\r\n\r\nNote: If your resource needs to access to state from a context hash, make sure to pass the context hash as the second argument of\r\nthe resource class new method. For example:\r\n\r\n```ruby\r\npost = Post.find(1)\r\ncontext = { current_user: current_user }\r\nJSONAPI::ResourceSerializer.new(PostResource).serialize_to_hash(PostResource.new(post, context))\r\n```\r\n\r\nThis returns results like this:\r\n\r\n```json\r\n{\r\n  \"data\": {\r\n    \"type\": \"posts\",\r\n    \"id\": \"1\",\r\n    \"links\": {\r\n      \"self\": \"http://example.com/posts/1\"\r\n    },\r\n    \"attributes\": {\r\n      \"title\": \"New post\",\r\n      \"body\": \"A body!!!\",\r\n      \"subject\": \"New post\"\r\n    },\r\n    \"relationships\": {\r\n      \"section\": {\r\n        \"links\": {\r\n          \"self\": \"http://example.com/posts/1/relationships/section\",\r\n          \"related\": \"http://example.com/posts/1/section\"\r\n        },\r\n        \"data\": null\r\n      },\r\n      \"author\": {\r\n        \"links\": {\r\n          \"self\": \"http://example.com/posts/1/relationships/author\",\r\n          \"related\": \"http://example.com/posts/1/author\"\r\n        },\r\n        \"data\": {\r\n          \"type\": \"people\",\r\n          \"id\": \"1\"\r\n        }\r\n      },\r\n      \"tags\": {\r\n        \"links\": {\r\n          \"self\": \"http://example.com/posts/1/relationships/tags\",\r\n          \"related\": \"http://example.com/posts/1/tags\"\r\n        }\r\n      },\r\n      \"comments\": {\r\n        \"links\": {\r\n          \"self\": \"http://example.com/posts/1/relationships/comments\",\r\n          \"related\": \"http://example.com/posts/1/comments\"\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n#### Serializer options\r\n\r\nThe `ResourceSerializer` can be initialized with some optional parameters:\r\n\r\n##### `include`\r\n\r\nAn array of resources. Nested resources can be specified with dot notation.\r\n\r\n  *Purpose*: determines which objects will be side loaded with the source objects in an `included` section\r\n\r\n  *Example*: ```include: ['comments','author','comments.tags','author.posts']```\r\n\r\n##### `fields`\r\n\r\nA hash of resource types and arrays of fields for each resource type.\r\n\r\n  *Purpose*: determines which fields are serialized for a resource type. This encompasses both attributes and\r\n  relationship ids in the links section for a resource. Fields are global for a resource type.\r\n\r\n  *Example*: ```fields: { people: [:email, :comments], posts: [:title, :author], comments: [:body, :post]}```\r\n\r\n```ruby\r\npost = Post.find(1)\r\ninclude_resources = ['comments','author','comments.tags','author.posts']\r\n\r\nJSONAPI::ResourceSerializer.new(PostResource, include: include_resources,\r\n  fields: {\r\n    people: [:email, :comments],\r\n    posts: [:title, :author],\r\n    tags: [:name],\r\n    comments: [:body, :post]\r\n  }\r\n).serialize_to_hash(PostResource.new(post, nil))\r\n```\r\n\r\n#### Formatting\r\n\r\nJR by default uses some simple rules to format (and unformat) an attribute for (de-)serialization. Strings and Integers are output to JSON\r\nas is, and all other values have `.to_s` applied to them. This outputs something in all cases, but it is certainly not\r\ncorrect for every situation.\r\n\r\nIf you want to change the way an attribute is (de-)serialized you have a couple of ways. The simplest method is to create a\r\ngetter (and setter) method on the resource which overrides the attribute and apply the (un-)formatting there. For example:\r\n\r\n```ruby\r\nclass PersonResource < JSONAPI::Resource\r\n  attributes :name, :email, :last_login_time\r\n\r\n  # Setter example\r\n  def email=(new_email)\r\n    @model.email = new_email.downcase\r\n  end\r\n\r\n  # Getter example\r\n  def last_login_time\r\n    @model.last_login_time.in_time_zone(@context[:current_user].time_zone).to_s\r\n  end\r\nend\r\n```\r\n\r\nThis is simple to implement for a one off situation, but not for example if you want to apply the same formatting rules\r\nto all DateTime fields in your system. Another issue is the attribute on the resource will always return a formatted\r\nresponse, whether you want it or not.\r\n\r\n##### Value Formatters\r\n\r\nTo overcome the above limitations JR uses Value Formatters. Value Formatters allow you to control the way values are\r\nhandled for an attribute. The `format` can be set per attribute as it is declared in the resource. For example:\r\n\r\n```ruby\r\nclass PersonResource < JSONAPI::Resource\r\n  attributes :name, :email, :spoken_languages\r\n  attribute :last_login_time, format: :date_with_utc_timezone\r\n\r\n  # Getter/Setter for spoken_languages ...\r\nend\r\n```\r\n\r\nA Value formatter has a `format` and an `unformat` method. Here's the base ValueFormatter and DefaultValueFormatter for\r\nreference:\r\n\r\n```ruby\r\nmodule JSONAPI\r\n  class ValueFormatter < Formatter\r\n    class << self\r\n      def format(raw_value)\r\n        super(raw_value)\r\n      end\r\n\r\n      def unformat(value)\r\n        super(value)\r\n      end\r\n      ...\r\n    end\r\n  end\r\nend\r\n\r\nclass DefaultValueFormatter < JSONAPI::ValueFormatter\r\n  class << self\r\n    def format(raw_value)\r\n      case raw_value\r\n        when Date, Time, DateTime, ActiveSupport::TimeWithZone, BigDecimal\r\n          # Use the as_json methods added to various base classes by ActiveSupport\r\n          return raw_value.as_json\r\n        else\r\n          return raw_value\r\n      end\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nYou can also create your own Value Formatter. Value Formatters must be named with the `format` name followed by\r\n`ValueFormatter`, i.e. `DateWithUTCTimezoneValueFormatter` and derive from `JSONAPI::ValueFormatter`. It is\r\nrecommended that you create a directory for your formatters, called `formatters`.\r\n\r\nThe `format` method is called by the `ResourceSerializer` as is serializing a resource. The format method takes the\r\n`raw_value` parameter. `raw_value` is the value as read from the model.\r\n\r\nThe `unformat` method is called when processing the request. Each incoming attribute (except `links`) are run through\r\nthe `unformat` method. The `unformat` method takes a `value`, which is the value as it comes in on the\r\nrequest. This allows you process the incoming value to alter its state before it is stored in the model.\r\n\r\n###### Use a Different Default Value Formatter\r\n\r\nAnother way to handle formatting is to set a different default value formatter. This will affect all attributes that do\r\nnot have a `format` set. You can do this by overriding the `default_attribute_options` method for a resource (or a base\r\nresource for a system wide change).\r\n\r\n```ruby\r\n  def self.default_attribute_options\r\n    {format: :my_default}\r\n  end\r\n```\r\n\r\nand\r\n\r\n```ruby\r\nclass MyDefaultValueFormatter < DefaultValueFormatter\r\n  class << self\r\n    def format(raw_value)\r\n      case raw_value\r\n        when DateTime\r\n          return super(raw_value.in_time_zone('UTC'))\r\n        else\r\n          return super\r\n      end\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nThis way all DateTime values will be formatted to display in the UTC timezone.\r\n\r\n#### Key Format\r\n\r\nBy default JR uses dasherized keys as per the\r\n[JSON API naming recommendations](http://jsonapi.org/recommendations/#naming).  This can be changed by specifying a\r\ndifferent key formatter.\r\n\r\nFor example, to use camel cased keys with an initial lowercase character (JSON's default) create an initializer and add\r\nthe following:\r\n\r\n```ruby\r\nJSONAPI.configure do |config|\r\n  # built in key format options are :underscored_key, :camelized_key and :dasherized_key\r\n  config.json_key_format = :camelized_key\r\nend\r\n```\r\n\r\nThis will cause the serializer to use the `CamelizedKeyFormatter`. You can also create your own `KeyFormatter`, for\r\nexample:\r\n\r\n```ruby\r\nclass UpperCamelizedKeyFormatter < JSONAPI::KeyFormatter\r\n  class << self\r\n    def format(key)\r\n      super.camelize(:upper)\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nYou would specify this in `JSONAPI.configure` as `:upper_camelized`.\r\n\r\n### Routing\r\n\r\nJR has a couple of helper methods available to assist you with setting up routes.\r\n\r\n##### `jsonapi_resources`\r\n\r\nLike `resources` in `ActionDispatch`, `jsonapi_resources` provides resourceful routes mapping between HTTP verbs and URLs\r\nand controller actions. This will also setup mappings for relationship URLs for a resource's relationships. For example:\r\n\r\n```ruby\r\nRails.application.routes.draw do\r\n  jsonapi_resources :contacts\r\n  jsonapi_resources :phone_numbers\r\nend\r\n```\r\n\r\ngives the following routes\r\n\r\n```\r\n                     Prefix Verb      URI Pattern                                               Controller#Action\r\ncontact_relationships_phone_numbers GET       /contacts/:contact_id/relationships/phone-numbers(.:format)       contacts#show_relationship {:relationship=>\"phone_numbers\"}\r\n                            POST      /contacts/:contact_id/relationships/phone-numbers(.:format)       contacts#create_relationship {:relationship=>\"phone_numbers\"}\r\n                            DELETE    /contacts/:contact_id/relationships/phone-numbers/:keys(.:format) contacts#destroy_relationship {:relationship=>\"phone_numbers\"}\r\n      contact_phone_numbers GET       /contacts/:contact_id/phone-numbers(.:format)             phone_numbers#get_related_resources {:relationship=>\"phone_numbers\", :source=>\"contacts\"}\r\n                   contacts GET       /contacts(.:format)                                       contacts#index\r\n                            POST      /contacts(.:format)                                       contacts#create\r\n                    contact GET       /contacts/:id(.:format)                                   contacts#show\r\n                            PATCH     /contacts/:id(.:format)                                   contacts#update\r\n                            PUT       /contacts/:id(.:format)                                   contacts#update\r\n                            DELETE    /contacts/:id(.:format)                                   contacts#destroy\r\n phone_number_relationships_contact GET       /phone-numbers/:phone_number_id/relationships/contact(.:format)   phone_numbers#show_relationship {:relationship=>\"contact\"}\r\n                            PUT|PATCH /phone-numbers/:phone_number_id/relationships/contact(.:format)   phone_numbers#update_relationship {:relationship=>\"contact\"}\r\n                            DELETE    /phone-numbers/:phone_number_id/relationships/contact(.:format)   phone_numbers#destroy_relationship {:relationship=>\"contact\"}\r\n       phone_number_contact GET       /phone-numbers/:phone_number_id/contact(.:format)         contacts#get_related_resource {:relationship=>\"contact\", :source=>\"phone_numbers\"}\r\n              phone_numbers GET       /phone-numbers(.:format)                                  phone_numbers#index\r\n                            POST      /phone-numbers(.:format)                                  phone_numbers#create\r\n               phone_number GET       /phone-numbers/:id(.:format)                              phone_numbers#show\r\n                            PATCH     /phone-numbers/:id(.:format)                              phone_numbers#update\r\n                            PUT       /phone-numbers/:id(.:format)                              phone_numbers#update\r\n                            DELETE    /phone-numbers/:id(.:format)                              phone_numbers#destroy\r\n```\r\n\r\n##### `jsonapi_resource`\r\n\r\nLike `jsonapi_resources`, but for resources you lookup without an id.\r\n\r\n#### Nested Routes\r\n\r\nBy default nested routes are created for getting related resources and manipulating relationships. You can control the\r\nnested routes by passing a block into `jsonapi_resources` or `jsonapi_resource`. An empty block will not create\r\nany nested routes. For example:\r\n\r\n```ruby\r\nRails.application.routes.draw do\r\n  jsonapi_resources :contacts do\r\n  end\r\nend\r\n```\r\n\r\ngives routes that are only related to the primary resource, and none for its relationships:\r\n\r\n```\r\n      Prefix Verb   URI Pattern                  Controller#Action\r\n    contacts GET    /contacts(.:format)          contacts#index\r\n             POST   /contacts(.:format)          contacts#create\r\n     contact GET    /contacts/:id(.:format)      contacts#show\r\n             PATCH  /contacts/:id(.:format)      contacts#update\r\n             PUT    /contacts/:id(.:format)      contacts#update\r\n             DELETE /contacts/:id(.:format)      contacts#destroy\r\n```\r\n\r\nTo manually add in the nested routes you can use the `jsonapi_links`, `jsonapi_related_resources` and\r\n`jsonapi_related_resource` inside the block. Or, you can add the default set of nested routes using the\r\n`jsonapi_relationships` method. For example:\r\n\r\n```ruby\r\nRails.application.routes.draw do\r\n  jsonapi_resources :contacts do\r\n    jsonapi_relationships\r\n  end\r\nend\r\n```\r\n\r\n###### `jsonapi_links`\r\n\r\nYou can add relationship routes in with `jsonapi_links`, for example:\r\n\r\n```ruby\r\nRails.application.routes.draw do\r\n  jsonapi_resources :contacts do\r\n    jsonapi_links :phone_numbers\r\n  end\r\nend\r\n```\r\n\r\nGives the following routes:\r\n\r\n```\r\ncontact_relationships_phone_numbers GET    /contacts/:contact_id/relationships/phone-numbers(.:format)       contacts#show_relationship {:relationship=>\"phone_numbers\"}\r\n                            POST   /contacts/:contact_id/relationships/phone-numbers(.:format)       contacts#create_relationship {:relationship=>\"phone_numbers\"}\r\n                            DELETE /contacts/:contact_id/relationships/phone-numbers/:keys(.:format) contacts#destroy_relationship {:relationship=>\"phone_numbers\"}\r\n                   contacts GET    /contacts(.:format)                                       contacts#index\r\n                            POST   /contacts(.:format)                                       contacts#create\r\n                    contact GET    /contacts/:id(.:format)                                   contacts#show\r\n                            PATCH  /contacts/:id(.:format)                                   contacts#update\r\n                            PUT    /contacts/:id(.:format)                                   contacts#update\r\n                            DELETE /contacts/:id(.:format)                                   contacts#destroy\r\n\r\n```\r\n\r\nThe new routes allow you to show, create and destroy the relationships between resources.\r\n\r\n###### `jsonapi_related_resources`\r\n\r\nCreates a nested route to GET the related has_many resources. For example:\r\n\r\n```ruby\r\nRails.application.routes.draw do\r\n  jsonapi_resources :contacts do\r\n    jsonapi_related_resources :phone_numbers\r\n  end\r\nend\r\n\r\n```\r\n\r\ngives the following routes:\r\n\r\n```\r\n               Prefix Verb   URI Pattern                                   Controller#Action\r\ncontact_phone_numbers GET    /contacts/:contact_id/phone-numbers(.:format) phone_numbers#get_related_resources {:relationship=>\"phone_numbers\", :source=>\"contacts\"}\r\n             contacts GET    /contacts(.:format)                           contacts#index\r\n                      POST   /contacts(.:format)                           contacts#create\r\n              contact GET    /contacts/:id(.:format)                       contacts#show\r\n                      PATCH  /contacts/:id(.:format)                       contacts#update\r\n                      PUT    /contacts/:id(.:format)                       contacts#update\r\n                      DELETE /contacts/:id(.:format)                       contacts#destroy\r\n\r\n```\r\n\r\nA single additional route was created to allow you GET the phone numbers through the contact.\r\n\r\n###### `jsonapi_related_resource`\r\n\r\nLike `jsonapi_related_resources`, but for has_one related resources.\r\n\r\n```ruby\r\nRails.application.routes.draw do\r\n  jsonapi_resources :phone_numbers do\r\n    jsonapi_related_resource :contact\r\n  end\r\nend\r\n```\r\n\r\ngives the following routes:\r\n\r\n```\r\n              Prefix Verb   URI Pattern                                       Controller#Action\r\nphone_number_contact GET    /phone-numbers/:phone_number_id/contact(.:format) contacts#get_related_resource {:relationship=>\"contact\", :source=>\"phone_numbers\"}\r\n       phone_numbers GET    /phone-numbers(.:format)                          phone_numbers#index\r\n                     POST   /phone-numbers(.:format)                          phone_numbers#create\r\n        phone_number GET    /phone-numbers/:id(.:format)                      phone_numbers#show\r\n                     PATCH  /phone-numbers/:id(.:format)                      phone_numbers#update\r\n                     PUT    /phone-numbers/:id(.:format)                      phone_numbers#update\r\n                     DELETE /phone-numbers/:id(.:format)                      phone_numbers#destroy\r\n\r\n```\r\n\r\n### Authorization\r\n\r\nCurrently `json-api-resources` doesn't come with built-in primitives for authorization. However multiple users of the framework have come up with different approaches, check out:\r\n\r\n- [jsonapi-authorization](https://github.com/venuu/jsonapi-authorization)\r\n- [pundit-resources](https://github.com/togglepro/pundit-resources)\r\n\r\nRefer to the comments/discussion [here](https://github.com/cerebris/jsonapi-resources/issues/16#issuecomment-222438975) for the differences between approaches\r\n\r\n### Resource Caching\r\n\r\nTo improve the response time of GET requests, JR can cache the generated JSON fragments for\r\nResources which are suitable. First, set `config.resource_cache` to an ActiveSupport cache store:\r\n\r\n```ruby\r\nJSONAPI.configure do |config|\r\n  config.resource_cache = Rails.cache\r\nend\r\n```\r\n\r\nThen, on each Resource you want to cache, call the `caching` method:\r\n\r\n```ruby\r\nclass PostResource < JSONAPI::Resource\r\n  caching\r\nend\r\n```\r\n\r\nSee the caveats section below for situations where you might not want to enable caching on particular\r\nResources.\r\n\r\nThe Resource model must also have a field that is updated whenever any of the model's data changes.\r\nThe default Rails timestamps handle this pretty well, and the default cache key field is `updated_at` for this reason.\r\nYou can use an alternate field (which you are then responsible for updating) by calling the `cache_field` method:\r\n\r\n```ruby\r\nclass PostResource < JSONAPI::Resource\r\n  caching\r\n  cache_field :change_counter\r\n\r\n  before_save do\r\n    if self.change_counter.nil?\r\n      self.change_counter = 1\r\n    elsif self.changed?\r\n      self.change_counter += 1\r\n    end\r\n  end\r\n\r\n  after_touch do\r\n    update_attribute(:change_counter, self.change_counter + 1)\r\n  end\r\nend\r\n```\r\n\r\nIf context affects the content of the serialized result, you must define a class method `attribute_caching_context` on that Resource, which should return a different value for contexts that produce different results. In particular, if the `meta` or `fetchable_fields` methods, or any method providing the actual content of an attribute, changes depending on context, then you must provide `attribute_caching_context`. The actual value it\r\nreturns isn't important, what matters is that the value must be different if any relevant part of the context is different.\r\n\r\n```ruby\r\nclass PostResource < JSONAPI::Resource\r\n  caching\r\n\r\n  attributes :title, :body, :secret_field\r\n\r\n  def fetchable_fields\r\n    return super if context.user.superuser?\r\n    return super - [:secret_field]\r\n  end\r\n\r\n  def meta\r\n    if context.user.can_see_creation_dates?\r\n      return { created: _model.created_at }\r\n    else\r\n      return {}\r\n    end\r\n  end\r\n\r\n  def self.attribute_caching_context(context)\r\n    return {\r\n      admin: context.user.superuser?,\r\n      creation_date_viewer: context.user.can_see_creation_dates?\r\n    }\r\n  end\r\nend\r\n```\r\n\r\n#### Caching Caveats\r\n\r\n* Models for cached Resources must update a cache key field whenever their data changes. However, if you bypass Rails and e.g. alter the database row directly without changing the `updated_at` field, the cached entry for that resource will be inaccurate. Also, `updated_at` provides a narrow race condition window; if a resource is updated twice in the same second, it's possible that only the first update will be cached. If you're concerned about this, you will need to find a way to make sure your models' cache fields change on every update, e.g. by using a unique random value or a monotonic clock.\r\n* If an attribute's value is affected by related resources, e.g. the `spoken_languages` example above, then changes to the related resource must also touch the cache field on the resource that uses it. The `belongs_to` relation in ActiveRecord provides a `:touch` option for this purpose.\r\n* JR does not actively clean the cache, so you must use an ActiveSupport cache that automatically expires old entries, or you will leak resources. The MemoryCache built in to Rails does this by default, but other caches will have to be configured with an `:expires_in` option and/or a cache-specific clearing mechanism.\r\n* Similarly, if you make a substantial code change that affects a lot of serialized representations (i.e. changing the way an attribute is shown), you'll have to clear out all relevant cache entries yourself. The simplest way to do this is to run `JSONAPI.configuration.resource_cache.clear` from the console. You do not have to do this after merely adding or removing attributes; only changes that affect the actual content of attributes require manual cache clearing.\r\n* If resource caching is enabled at all, then custom relationship methods on any resource might not always be used, even resources that are not cached. For example, if you manually define a `comments` method or `records_for_comments` method on a Resource that `has_many :comments`, you cannot expect it to be used when caching is enabled, even if you never call `caching` on that particular Resource. Instead, you should use relationship name lambdas.\r\n* The above also applies to custom `find` or `find_by_key` methods. Instead, if you are using resource caching anywhere in your app, try overriding the `find_records` method to return an appropriate `ActiveRecord::Relation`.\r\n* Caching relies on ActiveRecord features; you cannot enable caching on resources based on non-AR models, e.g. PORO objects or singleton resources.\r\n* If you write a custom `ResourceSerializer` which takes new options, then you must define `config_description` to include those options if they might impact the serialized value:\r\n\r\n```ruby\r\nclass MySerializer < JSONAPI::ResourceSerializer\r\n  def initialize(primary_resource_klass, options = {})\r\n    @my_special_option = options.delete(:my_special_option)\r\n    super\r\n  end\r\n\r\n  def config_description(resource_klass)\r\n    super.merge({my_special_option: @my_special_option})\r\n  end\r\nend\r\n```\r\n\r\n## Configuration\r\n\r\nJR has a few configuration options. Some have already been mentioned above. To set configuration options create an\r\ninitializer and add the options you wish to set. All options have defaults, so you only need to set the options that\r\nare different. The default options are shown below.\r\n\r\nIf using custom classes (such as a CustomPaginator), be sure to require them at the top of the initializer before usage.\r\n\r\n```ruby\r\nJSONAPI.configure do |config|\r\n  #:underscored_key, :camelized_key, :dasherized_key, or custom\r\n  config.json_key_format = :dasherized_key\r\n\r\n  #:underscored_route, :camelized_route, :dasherized_route, or custom\r\n  config.route_format = :dasherized_route\r\n\r\n  # Default Processor, used if a resource specific one is not defined.\r\n  # Must be a class\r\n  config.default_processor_klass = JSONAPI::Processor\r\n\r\n  #:integer, :uuid, :string, or custom (provide a proc)\r\n  config.resource_key_type = :integer\r\n\r\n  # optional request features\r\n  config.allow_include = true\r\n  config.allow_sort = true\r\n  config.allow_filter = true\r\n\r\n  # How to handle unsupported attributes and relationships which are provided in the request\r\n  # true => raises an error\r\n  # false => allows the request to continue. A warning is included in the response meta data indicating\r\n  # the fields which were ignored. This is useful for client libraries which send extra parameters.\r\n  config.raise_if_parameters_not_allowed = true\r\n\r\n  # :none, :offset, :paged, or a custom paginator name\r\n  config.default_paginator = :none\r\n\r\n  # Output pagination links at top level\r\n  config.top_level_links_include_pagination = true\r\n\r\n  config.default_page_size = 10\r\n  config.maximum_page_size = 20\r\n\r\n  # Output the record count in top level meta data for find operations\r\n  config.top_level_meta_include_record_count = false\r\n  config.top_level_meta_record_count_key = :record_count\r\n\r\n  # For :paged paginators, the following are also available\r\n  config.top_level_meta_include_page_count = false\r\n  config.top_level_meta_page_count_key = :page_count\r\n\r\n  config.use_text_errors = false\r\n\r\n  # List of classes that should not be rescued by the operations processor.\r\n  # For example, if you use Pundit for authorization, you might\r\n  # raise a Pundit::NotAuthorizedError at some point during operations\r\n  # processing. If you want to use Rails' `rescue_from` macro to\r\n  # catch this error and render a 403 status code, you should add\r\n  # the `Pundit::NotAuthorizedError` to the `exception_class_whitelist`.\r\n  # Subclasses of the whitelisted classes will also be whitelisted.\r\n  config.exception_class_whitelist = []\r\n\r\n  # Resource Linkage\r\n  # Controls the serialization of resource linkage for non compound documents\r\n  # NOTE: always_include_to_many_linkage_data is not currently implemented\r\n  config.always_include_to_one_linkage_data = false\r\n\r\n  # Relationship reflection invokes the related resource when updates\r\n  # are made to a has_many relationship. By default relationship_reflection\r\n  # is turned off because it imposes a small performance penalty.\r\n  config.use_relationship_reflection = false\r\n\r\n  # Allows transactions for creating and updating records\r\n  # Set this to false if your backend does not support transactions (e.g. Mongodb)\r\n  config.allow_transactions = true\r\n\r\n  # Formatter Caching\r\n  # Set to false to disable caching of string operations on keys and links.\r\n  # Note that unlike the resource cache, formatter caching is always done\r\n  # internally in-memory and per-thread; no ActiveSupport::Cache is used.\r\n  config.cache_formatters = true\r\n\r\n  # Resource cache\r\n  # An ActiveSupport::Cache::Store or similar, used by Resources with caching enabled.\r\n  # Set to `nil` (the default) to disable caching, or to `Rails.cache` to use the\r\n  # Rails cache store.\r\n  config.resource_cache = nil\r\n\r\n  # Default resource cache field\r\n  # On Resources with caching enabled, this field will be used to check for out-of-date\r\n  # cache entries, unless overridden on a specific Resource. Defaults to \"updated_at\".\r\n  config.default_resource_cache_field = :updated_at\r\n\r\n  # Resource cache digest function\r\n  # Provide a callable that returns a unique value for string inputs with\r\n  # low chance of collision. The default is SHA256 base64.\r\n  config.resource_cache_digest_function = Digest::SHA2.new.method(:base64digest)\r\n\r\n  # Resource cache usage reporting\r\n  # Optionally provide a callable which JSONAPI will call with information about cache\r\n  # performance. Should accept three arguments: resource name, hits count, misses count.\r\n  config.resource_cache_usage_report_function = nil\r\nend\r\n```\r\n\r\n## Contributing\r\n\r\n1. Fork it ( http://github.com/cerebris/jsonapi-resources/fork )\r\n2. Create your feature branch (`git checkout -b my-new-feature`)\r\n3. Commit your changes (`git commit -am 'Add some feature'`)\r\n4. Push to the branch (`git push origin my-new-feature`)\r\n5. Create a new Pull Request\r\n\r\n## License\r\n\r\nCopyright 2014-2016 Cerebris Corporation. MIT License (see LICENSE for details).\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}